// SPDX-License-Identifier: MIT
// to be moved into a proper npm package
// deploy params
// 0xFd36990172dFB44ef0cEa51a9B1159687CfBb4E2
// 1000000000000000000000

pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract MasaFaucet {
    address public tokenAddress;
    uint256 public tokenAmount;
    uint256 public dailyLimit = 1000 * 10**18;

    mapping(address => uint256) public nextRequestAt;
    mapping(address => uint256) public dailyTokenReceived;

    uint256 public waitTime = 1 hours;

    event EtherReceived(address indexed sender, uint256 amount);
    event TokensWithdrawn(address indexed admin, uint256 amount);
    event EtherWithdrawn(address indexed admin, uint256 amount);

    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor(address _tokenAddress, uint256 _tokenAmount) {
        tokenAddress = _tokenAddress;
        tokenAmount = _tokenAmount;
        owner = msg.sender;
    }

    function faucet() public {
        require(nextRequestAt[msg.sender] <= block.timestamp, "Please wait before requesting tokens again");

        uint256 currentDay = block.timestamp / 1 days;
        if (dailyTokenReceived[msg.sender] / 1 days < currentDay) {
            dailyTokenReceived[msg.sender] = 0;
        }
        
        require(dailyTokenReceived[msg.sender] >= dailyLimit, "Daily limit reached"); // TODO: check this

        IERC20 token = IERC20(tokenAddress);
        require(token.balanceOf(address(this)) >= tokenAmount, "Faucet is empty");

        nextRequestAt[msg.sender] = block.timestamp + waitTime;
        dailyTokenReceived[msg.sender] += tokenAmount;
        token.transfer(msg.sender, tokenAmount);
    }
    // Function to withdraw remaining tokens (if needed)
    function withdrawTokens(uint256 amount) onlyOwner public {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(msg.sender, amount), "Withdraw failed");
        emit TokensWithdrawn(msg.sender, amount);
    }

    // Function to withdraw Ether
    function withdrawEther(uint256 amount) onlyOwner public {
        require(address(this).balance >= amount, "Insufficient Ether balance");
        payable(msg.sender).transfer(amount);
        emit EtherWithdrawn(msg.sender, amount);
    }

    // Function to change the wait time (if needed)
    function setWaitTime(uint256 _waitTime) onlyOwner public {
        waitTime = _waitTime;
    }

    // Function to change the token amount (if needed)
    function setTokenAmount(uint256 _tokenAmount) onlyOwner public {
        tokenAmount = _tokenAmount;
    }

    // Function to change the daily limit (if needed)
    function setDailyLimit(uint256 _dailyLimit) onlyOwner public {
        dailyLimit = _dailyLimit;
    }

    // Function to receive Ether
    receive() external payable {
        emit EtherReceived(msg.sender, msg.value);
    }
}
